{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"INTEGRASI NUMERIK \u00b6 Integrasi numerik adalah peranan penting di dalam masalah sains dan teknik. Hal ini yang sering ada di dalam bidang sains ditemukan ungkapan ungkapan integral matematis yang tidak mudah dan bahkan tidak dapat diselesaikan secara analitis. Dalam bab ini kita akan membahas beberapa teknik integrasi numerik yang sangat umum digunakan untuk memperoleh pendekatan integral fungsi y(x) pada batas interval [a,b]. Secara umum digunakan untuk memperoleh pendekataan integral fungsi y(x) pada interval tersebut dapat dinyatakan sebagai berikut. I =\\int ^{b}_{x=a}f\\left( x\\right) dx \u200b Ungkapan (3-1) dapat diartikan sebagai integral dari fungsi y(x) terhadap perubahan bebas x yang di evaluasi mulai dari x = a hingga x = b. pendapatan numerik terhadap ungkapan integral (3-1) dapat dinyatakan sebagai berikut. I\\left( x\\right) =\\sum ^{N}_{i=1}w_{i}y\\left( x_{i}\\right) dengan N menyatakan jumlah segmen, y(x1)=y(a) dan y(xn)=y(b). Apabila pendekatan numerik terhadap bentuk integral (3-1) merupakan jumlahan dari deret suku-suku dengan titik-titik Xi ini sering disebut sebagai titik simpul (node). Sedangkan, faktor pengali Wi disebut faktor bobot. f=\\int ^{b}y\\left( x\\right) dx I.I Metode Klasik \u00b6 Pada Metode Klasik, kita membahas beberapa metode integrasi numerik yang sering digunakan dalam mendekati ungkapan integral fungsi. X3,....,Xn dengan lebar segmen sebesar h, sehingga kita dapat definisikan Xi = X0 + ih , dengan i = 1,2,3,...,N Dengan demikian harga fungsi f(x) pada x= Xi adalah f\\left( x_{i}\\right) =f_{i} I.II Metode Trapesium \u00b6 Metode Trapesium adalah metode integrasi numerik yang didasarkan pada pennumlahan segmen-segmen berbentuk trapesium. Apabila sebuah integral didekati dengan metode trapesium dengan satu segmen saja, maka dapat dituliskan sebagai \\int ^{b}_{a}f\\left( x\\right) dx=\\dfrac{b-a}{2}\\left[ f\\left( a\\right) +f\\left( b\\right) \\right] +E Untuk memperoleh ungkapan metode trapesium (3-5) dan untuk mengetahui seberapa besar kesalahan yang dimiliki oleh metode ini, maka kita perlu melakukan ekspansi deret Taylor luasan A(x) yang didefinisikan sebagai A\\left( x\\right) \\int ^{x}_{x_{0}}f\\left( t\\right) dt Ekspnasi deret Taylor untuk luasan A(x) selanjutnya adalah A\\left( x\\right) =A\\left( x_{0}\\right) +\\left( x-x_{0}\\right)A^{'}\\left( x_{0}\\right) +\\dfrac{\\left( x-X_{0}\\right) ^{2}}{2}A''\\left( x_{0}\\right) +\\dfrac{\\left( x-x_{0}\\right) ^{3}}{6}A^{'''} dengan definisi (3-6) maka diperoleh \\begin{aligned}A^{'}\\left( x\\right) =f\\left( x\\right) ,A^{''}\\left( x\\right) =f^{'}\\left( x\\right) ,A^{'''}\\left( x\\right) =f^{''}\\left( x\\right) \\\\ .\\end{aligned} Untuk memperoleh ungkapan yang lebih teliti mengenai kesalahan pada metode ini, maka marilah kita lakukan perhitungan lebih teliti lagi. Jika kesalahan pendekatan dinyatakan sebagai E, maka \\begin{aligned}\\begin{aligned}f=\\int ^{x_{0}}_{x_{0}}f^{+h}\\left( x\\right) dx-\\dfrac{h}{2}\\left[ f\\left( x_{0}+h\\right) \\right] \\\\ =\\left[ hf\\left( x_{0}\\right) +\\dfrac{h^{2}}{2}f'\\left( x_{0}\\right) +\\ldots \\right] -\\\\ \\dfrac{h}{2}( f\\left( x_{0}\\right) +f\\left( x_{0}\\right) t\\cdot hf'\\left( x_{0}\\right) +\\dfrac{h^{2}}{2}f'''\\left( x_{0}\\right) +\\ldots ] \\end{aligned}\\\\ \\approx -\\dfrac{1}{12}h^{3}f''\\left( x_{0}\\right) \\end{aligned} Algoritma program untuk aturan trapesium ini dapat dinyatakan sebagai berikut: \u2022 Mendefinisikan fungsi yang akan diintegrasikan \u2022 Menentukan batas bawah b dan batas atas a integrasi \u2022 Menghitung lebar segmen yaitu h= b\u2212a/N \u2022 Inisialisasi (memberikan harga awal) fungsi yang diintegrasikan yaitu I=f(a)+f(b) \u2022 Menghitung I untuk n=1 hingga n=N-1 \u2022 Mencetak hasil perhitungan Di bawah ini diberikan contoh program komputer untuk aturan trapesium untuk melakukan pendekatan hasil pada \\int ^{1}_{0}\\left( 4^{x}-x^{2}\\right) dx %Program Aturan_Trapesium f=inline('4*x-x^2','x'); hasil_eksak=1.6667; a=input('masukkan batas bawah integrasi :'); b=input(' masukkan batas atas integrasi :'); N=input('masukkan jumlah segmen N :'); h=(b-a)/N; sum=f(a)+f(b); \u200b fak=2 \u200b for i=1:N-1 \u200b x=a+i*h; \u200b sum=sum+2*f(x) \u200b end hasil_numerik=sum*h/2.; selisih=hasil_eksak-hasil_numerik; kesalahan=abs(selisih/hasil_eksak); fprintf('%f %f',hasil_numerik,kesalahan); Numerical Solution of system of Linear Algebraic Equatic \u00b6 Solusi Numerik adalah Salah satu aspek yang paling dapat diandalkan dari program analisis numerik untuk komputer digital elektronik adalah bahwa program tersebut selalu menghasilkan angka. Sebagai hasil dari keandalan yang cukup besar dari mesin, adalah umum untuk menganggap hasil perhitungan mereka dengan udara infalibilitas tertentu. Namun, hasilnya tidak lebih baik dari metode analisis dan implementasi program yang digunakan oleh komputer. Secara umum, bentuk titik-mengambang suatu bilangan adalah \u00b1M x10k, di mana k adalah bilangan bulat dan mantissa M adalah bilangan real (desimal) yang memenuhi 0,1 M < 1. Jumlah maksimum tempat desimal yang dapat disimpan di mantissa tergantung pada komputer. Jika jumlah maksimum tempat desimal yang dapat disimpan adalah d, kita katakan bahwa ada d angka penting. Sistem Linear Persamaan Aljabar Aljabar linier telah berkembang sebagai cabang matematika dengan berbagai aplikasi dalam ilmu alam, teknik, ilmu komputer, manajemen dan ilmu sosial, dan banyak lagi. Banyak masalah dalam sains mengarah pada pemecahan lebih dari satu persamaan linier. Situasi umum dapat digambarkan dengan sistem linier. Sistem persamaan linear atau sistem linear adalah kumpulan berhingga dari. Sebuah sistem linier dapat memiliki banyak solusi (sistem dependen), tepat satu solusi (sistem independen) atau tidak ada solusi sama sekali. Ketika sistem linier memiliki solusi, kita katakan bahwa sistem tersebut konsisten. Jika tidak, sistem dikatakan tidak konsisten. bentuk cise, dapat ditulis sebagai 1 1, ,nij j ija xbim== =\u2211\u2026 (2) dimana aij, menunjukkan koefisien dari xj yang tidak diketahui ke-j dalam persamaan ke-i, dan bilangan aij, dan bi, (karenanya xj) semuanya nyata. Seringkali jumlah r persamaan sama dengan jumlah n yang tidak diketahui, tetapi pengecualian umum dalam optimasi dan pemodelan. Cara lain untuk merepresentasikan array adalah dengan mengapit ekspresi elemen-elemennya dalam kurung kurawal: A = { aij }, x = {xj}, b = {bi}. Mendefinisikan perkalian matriks-vektor 1nij jjAx ax=\uf8f1 (4) Sesuai dengan (2), kita dapat meringkas (1) secara ringkas sebagai [5], Ax b= (5) Metode penyelesaian ( 1) kemudian dapat dijelaskan dalam bentuk operasi pada larik A dan b, (1) memiliki solusi jika dan hanya jika b adalah kombinasi linier dari vektor kolom tak nol dari A; maka kita katakan bahwa b berada di ruang kolom A. Dalam kasus seperti itu, jika pangkat r, dari A sama dengan n ada solusi unik. di mana b1,\u2026,bn dan aij, sehingga 1 , 1 ,i m j n\u2264 diberikan elemen-elemen F. maka kita sebut (1) sistem persamaan linier m dalam n yang tidak diketahui. Sebarang n-tupel (x1,\u2026,xn) dari elemen-elemen F yang memenuhi setiap (1) disebut solusi sistem. Jika b1 = b2 =\u2026= bm = 0, dikatakan sistem homogen, atau setiap persamaan homogen. Dalam bentuk ringkas, (1) dapat ditulis sebagai \\sum ^{n}_{j=1}a_{ij}x_{j}=b_{i}i=1,\\ldots ,m Catatan, A menunjukkan matriks dengan koefisien aij,, x vektor kolom yang tidak diketahui dan b vektor kolom sebelah kanan. Cara lain untuk merepresentasikan array adalah dengan menyertakan ekspresi elemen-elemennya dalam kurung kurawal: A = { aij }, x = {xj}, b = {bi}. Mendefinisikan produk matriks-vektor Ax\\equiv \\left\\{ \\sum ^{n}_{j=1}a_{ij}x_{j}\\right\\} Sesuai dengan , seseorang dapat meringkas secara ringkas sebagai AX=b Methods of Solution \u00b6 Metode untuk penyelesaian kemudian dapat dijelaskan dalam bentuk operasi pada larik A dan b, memiliki solusi jika dan hanya jika b adalah kombinasi linier dari vektor kolom tak nol dari A; maka kita katakan bahwa b berada di ruang kolom A. Dalam kasus seperti itu, jika pangkat r, dari A sama dengan n, ada solusi unik, sedangkan jika r < n terdapat solusi tak terhingga yang dicirikan oleh (n - r) parameter bebas. Metode Penyelesaian Himpunan persamaan aljabar linier dapat dinyatakan sebagai persamaan tunggal, menggunakan notasi matriks seperti yang diberikan pada (3). Bentuk standar dan ringkas ini berguna untuk mengekspresikan solusi dan untuk mengembangkan aplikasi perangkat lunak dengan jumlah variabel yang berubah-ubah. Notasi matriks memungkinkan kita untuk merepresentasikan beberapa persamaan sebagai persamaan matriks tunggal. Ada beberapa algoritma untuk solusi sistem persamaan aljabar linier. Hanya tiga yang akan dibahas di sini berdasarkan fakta bahwa mereka akan digunakan untuk memecahkan masalah yang dipilih. Inversi Matriks \u00b6 Inversi Matriks Situasinya paling sederhana jika matriks A berbentuk bujur sangkar (r = n); maka vektor solusi unik x ada jika dan hanya jika pangkat A sama dengan orde n. Matriks A seperti itu memiliki invers unik, A-l, yang didefinisikan oleh A^{-1}A=AA^{-1}=I Kondisi perlu dan cukup untuk matriks A menjadi nonsingular adalah bahwa determinan A menjadi bukan nol. Dibawah kondisi ini, A\u2212 1 dihitung menggunakan persamaan berikut A^{-1}=\\dfrac{adj\\left( A\\right) }{\\det \\left( A\\right) } di mana adj(A) adalah matriks adjoint dari A yang adalah didefinisikan sebagai matriks n x n kofaktor yang diberikan oleh: Cij=\\left( -1\\right) ^{ij}\\det \\left( M_{ij}\\right) dan Mij adalah minor yang bersesuaian dengan aij dan didefinisikan sebagai matriks (n\u2212 1) x (n\u2212 1) yang diperoleh dengan mengeliminasi baris ke-i dan kolom ke-j dari A. Invers dari matriks A didefinisikan hanya jika A persegi dan non tunggal. Suatu matriks dikatakan singular jika determinannya |A| aku s nol. Secara umum, determinan matriks A n x n didefinisikan sebagai: \\det \\left( A\\right) =\\sum ^{n}_{j=1}\\left( -1\\right) ^{*j}a_{ij}M_{ij} for any i =1,2..,n Gauss Seidel \u00b6 Metode seidel pada dasarnya sama dengan metode jacobi hanya saja ketika nilai terbaru dari x (misal x1(1) sudah ditemukan maka akan langsung dipakai untuk mencari nilai x selanjutnya) Algoritma \u00b6 Yang berbeda disini adalah kita membuat penampung x menjadi satu, jadi tidak ada wadah terpisah antara x lama dan x baru res = [0 for i in mtx] Kode \u00b6 n = int(input(\"Berapa variabel? \")) iterasi = int(input(\"Berapa iterasi? \")) mtx = [[float(input(\"Nilai untuk [{}][{}]=\".format(i,j))) for j in range(n+1)] for i in range(n)] starter = [float(input(\"Nilai awal X{}=\".format(i+1))) for i in range(n)] res = [0 for i in mtx] for h in range(iterasi): \u200b for i in range(len(mtx)): \u200b holder = mtx[i][-1] \u200b for j in range(len(mtx[i])-1): \u200b if i == j: \u200b continue \u200b holder -= mtx[i][j]*res[j] \u200b res[i] = holder/mtx[i][i] \u200b [print(\"X{}={}\".format(k, res[k]), end='\\t') for k in range(len(res))] \u200b print(\"\") Contoh \u00b6 Berapa variabel? 4 Berapa iterasi? 4 Nilai untuk [0][0]=10 Nilai untuk [0][1]=-1 Nilai untuk [0][2]=2 Nilai untuk [0][3]=0 Nilai untuk [0][4]=6 Nilai untuk [1][0]=-1 Nilai untuk [1][1]=11 Nilai untuk [1][2]=-1 Nilai untuk [1][3]=3 Nilai untuk [1][4]=25 Nilai untuk [2][0]=2 Nilai untuk [2][1]=-1 Nilai untuk [2][2]=10 Nilai untuk [2][3]=-1 Nilai untuk [2][4]=-11 Nilai untuk [3][0]=0 Nilai untuk [3][1]=3 Nilai untuk [3][2]=-1 Nilai untuk [3][3]=8 Nilai untuk [3][4]=15 Nilai awal X1=0 Nilai awal X2=0 Nilai awal X3=0 Nilai awal X4=0 X0=0.6 X1=0 X2=0 X3=0 X0=0.6 X1=2.3272727272727276 X2=0 X3=0 X0=0.6 X1=2.3272727272727276 X2=-0.9872727272727271 X3=0 X0=0.6 X1=2.3272727272727276 X2=-0.9872727272727271 X3=0.8788636363636363 X0=1.0301818181818183 X1=2.3272727272727276 X2=-0.9872727272727271 X3=0.8788636363636363 X0=1.0301818181818183 X1=2.0369380165289255 X2=-0.9872727272727271 X3=0.8788636363636363 X0=1.0301818181818183 X1=2.0369380165289255 X2=-1.0144561983471074 X3=0.8788636363636363 X0=1.0301818181818183 X1=2.0369380165289255 X2=-1.0144561983471074 X3=0.9843412190082644 X0=1.006585041322314 X1=2.0369380165289255 X2=-1.0144561983471074 X3=0.9843412190082644 X0=1.006585041322314 X1=2.003555016904583 X2=-1.0144561983471074 X3=0.9843412190082644 X0=1.006585041322314 X1=2.003555016904583 X2=-1.002527384673178 X3=0.9843412190082644 X0=1.006585041322314 X1=2.003555016904583 X2=-1.002527384673178 X3=0.9983509455766342 X0=1.000860978625094 X1=2.003555016904583 X2=-1.002527384673178 X3=0.9983509455766342 X0=1.000860978625094 X1=2.000298250656547 X2=-1.002527384673178 X3=0.9983509455766342 X0=1.000860978625094 X1=2.000298250656547 X2=-1.0003072761017007 X3=0.9983509455766342 X0=1.000860978625094 X1=2.000298250656547 X2=-1.0003072761017007 X3=0.9998497464910823 Numerical Solution of System of Ordinary Differential Equations \u00b6 Solusi Diiferensial \u00b6 Solusi Diiferensial adalah Persamaan diferensial biasa atau PDB adalah persamaan differensial yang mana fungsi yang tidak diketahui (variabel terikat) adalah fungsi dari variabel yang bebas tunggal. Bisa dibilang fungsi ini disebut juga dengan fungsi riil atau kompleks, tapi juga bisa disebut fungsi vektor atau matriks. Metode Euler \u00b6 Metode Euler adalah metode paling sederhana yang diturunkan dari deret taylor. \\begin{aligned}\\cdot \\\\ x_{i}+1=y_{i}+f\\left( x_{i},y_{i}\\right) h\\end{aligned} Algoritma \u00b6 Tentukan titik awal integrasi x0 dan y0 Tentukan jumlah iterasi (n) dan ukuran step (h) Eksekusi Kode \u00b6 import math # Contoh fungsi, bisa direplace def numeric(x,y,h): \u200b return y + (x*math.sqrt(y) * h) x = 0 y = 1 h = 0.25 interval = 1 while x <= interval: \u200b res = numeric(x,y,h) \u200b print(\"x = {}\".format(x)) \u200b print(\"y = {}\\n\".format(res)) \u200b y = res \u200b x+=h Contoh \u00b6 Selesaikan persamaan differensial \\dfrac{dy}{dx}=x\\sqrt{y} pada interval x = 0 s/d x = 1, h = \u00bc. Pada saat x = 0, nilai y = 1 x = 0 y = 1.0 `` x = 0.25 y = 1.0625 `` x = 0.5 y = 1.191347050800552 `` x = 0.75 y = 1.396001136405279 `` x = 1.0 y = 1.6913823663866876","title":"Home"},{"location":"#integrasi_numerik","text":"Integrasi numerik adalah peranan penting di dalam masalah sains dan teknik. Hal ini yang sering ada di dalam bidang sains ditemukan ungkapan ungkapan integral matematis yang tidak mudah dan bahkan tidak dapat diselesaikan secara analitis. Dalam bab ini kita akan membahas beberapa teknik integrasi numerik yang sangat umum digunakan untuk memperoleh pendekatan integral fungsi y(x) pada batas interval [a,b]. Secara umum digunakan untuk memperoleh pendekataan integral fungsi y(x) pada interval tersebut dapat dinyatakan sebagai berikut. I =\\int ^{b}_{x=a}f\\left( x\\right) dx \u200b Ungkapan (3-1) dapat diartikan sebagai integral dari fungsi y(x) terhadap perubahan bebas x yang di evaluasi mulai dari x = a hingga x = b. pendapatan numerik terhadap ungkapan integral (3-1) dapat dinyatakan sebagai berikut. I\\left( x\\right) =\\sum ^{N}_{i=1}w_{i}y\\left( x_{i}\\right) dengan N menyatakan jumlah segmen, y(x1)=y(a) dan y(xn)=y(b). Apabila pendekatan numerik terhadap bentuk integral (3-1) merupakan jumlahan dari deret suku-suku dengan titik-titik Xi ini sering disebut sebagai titik simpul (node). Sedangkan, faktor pengali Wi disebut faktor bobot. f=\\int ^{b}y\\left( x\\right) dx","title":"INTEGRASI NUMERIK"},{"location":"#ii_metode_klasik","text":"Pada Metode Klasik, kita membahas beberapa metode integrasi numerik yang sering digunakan dalam mendekati ungkapan integral fungsi. X3,....,Xn dengan lebar segmen sebesar h, sehingga kita dapat definisikan Xi = X0 + ih , dengan i = 1,2,3,...,N Dengan demikian harga fungsi f(x) pada x= Xi adalah f\\left( x_{i}\\right) =f_{i}","title":"I.I Metode Klasik"},{"location":"#iii_metode_trapesium","text":"Metode Trapesium adalah metode integrasi numerik yang didasarkan pada pennumlahan segmen-segmen berbentuk trapesium. Apabila sebuah integral didekati dengan metode trapesium dengan satu segmen saja, maka dapat dituliskan sebagai \\int ^{b}_{a}f\\left( x\\right) dx=\\dfrac{b-a}{2}\\left[ f\\left( a\\right) +f\\left( b\\right) \\right] +E Untuk memperoleh ungkapan metode trapesium (3-5) dan untuk mengetahui seberapa besar kesalahan yang dimiliki oleh metode ini, maka kita perlu melakukan ekspansi deret Taylor luasan A(x) yang didefinisikan sebagai A\\left( x\\right) \\int ^{x}_{x_{0}}f\\left( t\\right) dt Ekspnasi deret Taylor untuk luasan A(x) selanjutnya adalah A\\left( x\\right) =A\\left( x_{0}\\right) +\\left( x-x_{0}\\right)A^{'}\\left( x_{0}\\right) +\\dfrac{\\left( x-X_{0}\\right) ^{2}}{2}A''\\left( x_{0}\\right) +\\dfrac{\\left( x-x_{0}\\right) ^{3}}{6}A^{'''} dengan definisi (3-6) maka diperoleh \\begin{aligned}A^{'}\\left( x\\right) =f\\left( x\\right) ,A^{''}\\left( x\\right) =f^{'}\\left( x\\right) ,A^{'''}\\left( x\\right) =f^{''}\\left( x\\right) \\\\ .\\end{aligned} Untuk memperoleh ungkapan yang lebih teliti mengenai kesalahan pada metode ini, maka marilah kita lakukan perhitungan lebih teliti lagi. Jika kesalahan pendekatan dinyatakan sebagai E, maka \\begin{aligned}\\begin{aligned}f=\\int ^{x_{0}}_{x_{0}}f^{+h}\\left( x\\right) dx-\\dfrac{h}{2}\\left[ f\\left( x_{0}+h\\right) \\right] \\\\ =\\left[ hf\\left( x_{0}\\right) +\\dfrac{h^{2}}{2}f'\\left( x_{0}\\right) +\\ldots \\right] -\\\\ \\dfrac{h}{2}( f\\left( x_{0}\\right) +f\\left( x_{0}\\right) t\\cdot hf'\\left( x_{0}\\right) +\\dfrac{h^{2}}{2}f'''\\left( x_{0}\\right) +\\ldots ] \\end{aligned}\\\\ \\approx -\\dfrac{1}{12}h^{3}f''\\left( x_{0}\\right) \\end{aligned} Algoritma program untuk aturan trapesium ini dapat dinyatakan sebagai berikut: \u2022 Mendefinisikan fungsi yang akan diintegrasikan \u2022 Menentukan batas bawah b dan batas atas a integrasi \u2022 Menghitung lebar segmen yaitu h= b\u2212a/N \u2022 Inisialisasi (memberikan harga awal) fungsi yang diintegrasikan yaitu I=f(a)+f(b) \u2022 Menghitung I untuk n=1 hingga n=N-1 \u2022 Mencetak hasil perhitungan Di bawah ini diberikan contoh program komputer untuk aturan trapesium untuk melakukan pendekatan hasil pada \\int ^{1}_{0}\\left( 4^{x}-x^{2}\\right) dx %Program Aturan_Trapesium f=inline('4*x-x^2','x'); hasil_eksak=1.6667; a=input('masukkan batas bawah integrasi :'); b=input(' masukkan batas atas integrasi :'); N=input('masukkan jumlah segmen N :'); h=(b-a)/N; sum=f(a)+f(b); \u200b fak=2 \u200b for i=1:N-1 \u200b x=a+i*h; \u200b sum=sum+2*f(x) \u200b end hasil_numerik=sum*h/2.; selisih=hasil_eksak-hasil_numerik; kesalahan=abs(selisih/hasil_eksak); fprintf('%f %f',hasil_numerik,kesalahan);","title":"I.II Metode Trapesium"},{"location":"#numerical_solution_of_system_of_linear_algebraic_equatic","text":"Solusi Numerik adalah Salah satu aspek yang paling dapat diandalkan dari program analisis numerik untuk komputer digital elektronik adalah bahwa program tersebut selalu menghasilkan angka. Sebagai hasil dari keandalan yang cukup besar dari mesin, adalah umum untuk menganggap hasil perhitungan mereka dengan udara infalibilitas tertentu. Namun, hasilnya tidak lebih baik dari metode analisis dan implementasi program yang digunakan oleh komputer. Secara umum, bentuk titik-mengambang suatu bilangan adalah \u00b1M x10k, di mana k adalah bilangan bulat dan mantissa M adalah bilangan real (desimal) yang memenuhi 0,1 M < 1. Jumlah maksimum tempat desimal yang dapat disimpan di mantissa tergantung pada komputer. Jika jumlah maksimum tempat desimal yang dapat disimpan adalah d, kita katakan bahwa ada d angka penting. Sistem Linear Persamaan Aljabar Aljabar linier telah berkembang sebagai cabang matematika dengan berbagai aplikasi dalam ilmu alam, teknik, ilmu komputer, manajemen dan ilmu sosial, dan banyak lagi. Banyak masalah dalam sains mengarah pada pemecahan lebih dari satu persamaan linier. Situasi umum dapat digambarkan dengan sistem linier. Sistem persamaan linear atau sistem linear adalah kumpulan berhingga dari. Sebuah sistem linier dapat memiliki banyak solusi (sistem dependen), tepat satu solusi (sistem independen) atau tidak ada solusi sama sekali. Ketika sistem linier memiliki solusi, kita katakan bahwa sistem tersebut konsisten. Jika tidak, sistem dikatakan tidak konsisten. bentuk cise, dapat ditulis sebagai 1 1, ,nij j ija xbim== =\u2211\u2026 (2) dimana aij, menunjukkan koefisien dari xj yang tidak diketahui ke-j dalam persamaan ke-i, dan bilangan aij, dan bi, (karenanya xj) semuanya nyata. Seringkali jumlah r persamaan sama dengan jumlah n yang tidak diketahui, tetapi pengecualian umum dalam optimasi dan pemodelan. Cara lain untuk merepresentasikan array adalah dengan mengapit ekspresi elemen-elemennya dalam kurung kurawal: A = { aij }, x = {xj}, b = {bi}. Mendefinisikan perkalian matriks-vektor 1nij jjAx ax=\uf8f1 (4) Sesuai dengan (2), kita dapat meringkas (1) secara ringkas sebagai [5], Ax b= (5) Metode penyelesaian ( 1) kemudian dapat dijelaskan dalam bentuk operasi pada larik A dan b, (1) memiliki solusi jika dan hanya jika b adalah kombinasi linier dari vektor kolom tak nol dari A; maka kita katakan bahwa b berada di ruang kolom A. Dalam kasus seperti itu, jika pangkat r, dari A sama dengan n ada solusi unik. di mana b1,\u2026,bn dan aij, sehingga 1 , 1 ,i m j n\u2264 diberikan elemen-elemen F. maka kita sebut (1) sistem persamaan linier m dalam n yang tidak diketahui. Sebarang n-tupel (x1,\u2026,xn) dari elemen-elemen F yang memenuhi setiap (1) disebut solusi sistem. Jika b1 = b2 =\u2026= bm = 0, dikatakan sistem homogen, atau setiap persamaan homogen. Dalam bentuk ringkas, (1) dapat ditulis sebagai \\sum ^{n}_{j=1}a_{ij}x_{j}=b_{i}i=1,\\ldots ,m Catatan, A menunjukkan matriks dengan koefisien aij,, x vektor kolom yang tidak diketahui dan b vektor kolom sebelah kanan. Cara lain untuk merepresentasikan array adalah dengan menyertakan ekspresi elemen-elemennya dalam kurung kurawal: A = { aij }, x = {xj}, b = {bi}. Mendefinisikan produk matriks-vektor Ax\\equiv \\left\\{ \\sum ^{n}_{j=1}a_{ij}x_{j}\\right\\} Sesuai dengan , seseorang dapat meringkas secara ringkas sebagai AX=b","title":"Numerical Solution of system of Linear Algebraic Equatic"},{"location":"#methods_of_solution","text":"Metode untuk penyelesaian kemudian dapat dijelaskan dalam bentuk operasi pada larik A dan b, memiliki solusi jika dan hanya jika b adalah kombinasi linier dari vektor kolom tak nol dari A; maka kita katakan bahwa b berada di ruang kolom A. Dalam kasus seperti itu, jika pangkat r, dari A sama dengan n, ada solusi unik, sedangkan jika r < n terdapat solusi tak terhingga yang dicirikan oleh (n - r) parameter bebas. Metode Penyelesaian Himpunan persamaan aljabar linier dapat dinyatakan sebagai persamaan tunggal, menggunakan notasi matriks seperti yang diberikan pada (3). Bentuk standar dan ringkas ini berguna untuk mengekspresikan solusi dan untuk mengembangkan aplikasi perangkat lunak dengan jumlah variabel yang berubah-ubah. Notasi matriks memungkinkan kita untuk merepresentasikan beberapa persamaan sebagai persamaan matriks tunggal. Ada beberapa algoritma untuk solusi sistem persamaan aljabar linier. Hanya tiga yang akan dibahas di sini berdasarkan fakta bahwa mereka akan digunakan untuk memecahkan masalah yang dipilih.","title":"Methods of Solution"},{"location":"#inversi_matriks","text":"Inversi Matriks Situasinya paling sederhana jika matriks A berbentuk bujur sangkar (r = n); maka vektor solusi unik x ada jika dan hanya jika pangkat A sama dengan orde n. Matriks A seperti itu memiliki invers unik, A-l, yang didefinisikan oleh A^{-1}A=AA^{-1}=I Kondisi perlu dan cukup untuk matriks A menjadi nonsingular adalah bahwa determinan A menjadi bukan nol. Dibawah kondisi ini, A\u2212 1 dihitung menggunakan persamaan berikut A^{-1}=\\dfrac{adj\\left( A\\right) }{\\det \\left( A\\right) } di mana adj(A) adalah matriks adjoint dari A yang adalah didefinisikan sebagai matriks n x n kofaktor yang diberikan oleh: Cij=\\left( -1\\right) ^{ij}\\det \\left( M_{ij}\\right) dan Mij adalah minor yang bersesuaian dengan aij dan didefinisikan sebagai matriks (n\u2212 1) x (n\u2212 1) yang diperoleh dengan mengeliminasi baris ke-i dan kolom ke-j dari A. Invers dari matriks A didefinisikan hanya jika A persegi dan non tunggal. Suatu matriks dikatakan singular jika determinannya |A| aku s nol. Secara umum, determinan matriks A n x n didefinisikan sebagai: \\det \\left( A\\right) =\\sum ^{n}_{j=1}\\left( -1\\right) ^{*j}a_{ij}M_{ij} for any i =1,2..,n","title":"Inversi Matriks"},{"location":"#gauss_seidel","text":"Metode seidel pada dasarnya sama dengan metode jacobi hanya saja ketika nilai terbaru dari x (misal x1(1) sudah ditemukan maka akan langsung dipakai untuk mencari nilai x selanjutnya)","title":"Gauss Seidel"},{"location":"#algoritma","text":"Yang berbeda disini adalah kita membuat penampung x menjadi satu, jadi tidak ada wadah terpisah antara x lama dan x baru res = [0 for i in mtx]","title":"Algoritma"},{"location":"#kode","text":"n = int(input(\"Berapa variabel? \")) iterasi = int(input(\"Berapa iterasi? \")) mtx = [[float(input(\"Nilai untuk [{}][{}]=\".format(i,j))) for j in range(n+1)] for i in range(n)] starter = [float(input(\"Nilai awal X{}=\".format(i+1))) for i in range(n)] res = [0 for i in mtx] for h in range(iterasi): \u200b for i in range(len(mtx)): \u200b holder = mtx[i][-1] \u200b for j in range(len(mtx[i])-1): \u200b if i == j: \u200b continue \u200b holder -= mtx[i][j]*res[j] \u200b res[i] = holder/mtx[i][i] \u200b [print(\"X{}={}\".format(k, res[k]), end='\\t') for k in range(len(res))] \u200b print(\"\")","title":"Kode"},{"location":"#contoh","text":"Berapa variabel? 4 Berapa iterasi? 4 Nilai untuk [0][0]=10 Nilai untuk [0][1]=-1 Nilai untuk [0][2]=2 Nilai untuk [0][3]=0 Nilai untuk [0][4]=6 Nilai untuk [1][0]=-1 Nilai untuk [1][1]=11 Nilai untuk [1][2]=-1 Nilai untuk [1][3]=3 Nilai untuk [1][4]=25 Nilai untuk [2][0]=2 Nilai untuk [2][1]=-1 Nilai untuk [2][2]=10 Nilai untuk [2][3]=-1 Nilai untuk [2][4]=-11 Nilai untuk [3][0]=0 Nilai untuk [3][1]=3 Nilai untuk [3][2]=-1 Nilai untuk [3][3]=8 Nilai untuk [3][4]=15 Nilai awal X1=0 Nilai awal X2=0 Nilai awal X3=0 Nilai awal X4=0 X0=0.6 X1=0 X2=0 X3=0 X0=0.6 X1=2.3272727272727276 X2=0 X3=0 X0=0.6 X1=2.3272727272727276 X2=-0.9872727272727271 X3=0 X0=0.6 X1=2.3272727272727276 X2=-0.9872727272727271 X3=0.8788636363636363 X0=1.0301818181818183 X1=2.3272727272727276 X2=-0.9872727272727271 X3=0.8788636363636363 X0=1.0301818181818183 X1=2.0369380165289255 X2=-0.9872727272727271 X3=0.8788636363636363 X0=1.0301818181818183 X1=2.0369380165289255 X2=-1.0144561983471074 X3=0.8788636363636363 X0=1.0301818181818183 X1=2.0369380165289255 X2=-1.0144561983471074 X3=0.9843412190082644 X0=1.006585041322314 X1=2.0369380165289255 X2=-1.0144561983471074 X3=0.9843412190082644 X0=1.006585041322314 X1=2.003555016904583 X2=-1.0144561983471074 X3=0.9843412190082644 X0=1.006585041322314 X1=2.003555016904583 X2=-1.002527384673178 X3=0.9843412190082644 X0=1.006585041322314 X1=2.003555016904583 X2=-1.002527384673178 X3=0.9983509455766342 X0=1.000860978625094 X1=2.003555016904583 X2=-1.002527384673178 X3=0.9983509455766342 X0=1.000860978625094 X1=2.000298250656547 X2=-1.002527384673178 X3=0.9983509455766342 X0=1.000860978625094 X1=2.000298250656547 X2=-1.0003072761017007 X3=0.9983509455766342 X0=1.000860978625094 X1=2.000298250656547 X2=-1.0003072761017007 X3=0.9998497464910823","title":"Contoh"},{"location":"#numerical_solution_of_system_of_ordinary_differential_equations","text":"","title":"Numerical Solution of System of Ordinary Differential Equations"},{"location":"#solusi_diiferensial","text":"Solusi Diiferensial adalah Persamaan diferensial biasa atau PDB adalah persamaan differensial yang mana fungsi yang tidak diketahui (variabel terikat) adalah fungsi dari variabel yang bebas tunggal. Bisa dibilang fungsi ini disebut juga dengan fungsi riil atau kompleks, tapi juga bisa disebut fungsi vektor atau matriks.","title":"Solusi Diiferensial"},{"location":"#metode_euler","text":"Metode Euler adalah metode paling sederhana yang diturunkan dari deret taylor. \\begin{aligned}\\cdot \\\\ x_{i}+1=y_{i}+f\\left( x_{i},y_{i}\\right) h\\end{aligned}","title":"Metode Euler"},{"location":"#algoritma_1","text":"Tentukan titik awal integrasi x0 dan y0 Tentukan jumlah iterasi (n) dan ukuran step (h) Eksekusi","title":"Algoritma"},{"location":"#kode_1","text":"import math # Contoh fungsi, bisa direplace def numeric(x,y,h): \u200b return y + (x*math.sqrt(y) * h) x = 0 y = 1 h = 0.25 interval = 1 while x <= interval: \u200b res = numeric(x,y,h) \u200b print(\"x = {}\".format(x)) \u200b print(\"y = {}\\n\".format(res)) \u200b y = res \u200b x+=h","title":"Kode"},{"location":"#contoh_1","text":"Selesaikan persamaan differensial \\dfrac{dy}{dx}=x\\sqrt{y} pada interval x = 0 s/d x = 1, h = \u00bc. Pada saat x = 0, nilai y = 1 x = 0 y = 1.0 `` x = 0.25 y = 1.0625 `` x = 0.5 y = 1.191347050800552 `` x = 0.75 y = 1.396001136405279 `` x = 1.0 y = 1.6913823663866876","title":"Contoh"}]}